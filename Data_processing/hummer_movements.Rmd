---
title: "Hummingbird Movement"
author: "Gannon et al."
date: "2/24/2020"
output: html_document
bibliography: /Users/dusty/Documents/zotero_library.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)

  require(dplyr)
  require(stringr)
  require(sf)
  require(raster)
  require(lubridate)

```

 The final datasets will include observations of hummingbird movements among different RFID readers across the HJA meadows. We combine information on distances between readers, cover-type in which each reader was placed, proportion of intervening forest, and individual birds to inform models of hummingbird movement among foraging patches.
 
$~$ 

Read in RFID-reader data and reader location data:

```{r data}
#read in data
 vis <- read.table("~/Documents/Columbine/Data/Bird_data/all_visits2.txt", header = F, sep = "\t", as.is = T)
   names(vis) <- c("bird", "date", "time", "seconds", "complex", "reader")
# remove headquarters tests
   vis <- vis[-which(vis$complex == "HQ"), ]

# combine C-upper and C-lower with C
  # These readers are in the same meadow, so we can consider visits as evidence the bird in in that meadow
  vis$reader[which(vis$reader == "CU")] <- "C"
  vis$reader[which(vis$reader == "CL")] <- "C"
  vis$reader[which(vis$reader == "CW")] <- "C"
   
# combine complex and reader to make unique identifier for each reader
  vis$reader <- paste(vis$complex, vis$reader, sep = "_")

# load data on reader locations 
  rlocs <- read.table("~/Documents/Columbine/Data/Bird_data/hja_reader_locations_centercomb.txt", header = T, sep = "\t", as.is = T)
 
```

$~$

Remove any duplicated observations. The data were sometimes downloaded multiple times and resulted in duplicates.
```{r}

  vis <- vis[which(!duplicated(vis[,c(1:3)])), ]

```


 First, create a raw movement dataset.
 
```{r}

vis.sort <- vis[order(vis$bird, vis$date, vis$seconds), ]

  mv_raw <- data.frame(reader1=NA, reader2=NA, bird=NA)

  for(i in 2:nrow(vis.sort)){
    if((vis.sort$bird[i] == vis.sort$bird[i-1]) &
       (vis.sort$date[i] == vis.sort$date[i-1]) &
       (vis.sort$reader[i] != vis.sort$reader[i-1])){
      mv_raw <- rbind(mv_raw, 
                      c(vis.sort$reader[i-1], vis.sort$reader[i],
                        vis.sort$bird[i]))
       }
  }
  
  mv_raw <- mv_raw[-1,]
  length(unique(mv_raw$bird))

```


 To create the movement dataset, sort data by bird, then by date and time. Then, loop through data one row at a time to check that a bird moved from one reader to another within the same day.
 
```{r movements}

  vis.sort <- vis[order(vis$bird, vis$date, vis$seconds), ]

# add a column for the year
  vis.sort$year <- str_extract(vis.sort$date, "[[:digit:]]{4}")
  
# turn date into day of the year
  vis.sort$date2 <- ymd(vis.sort$date)
  vis.sort$day <- yday(vis.sort$date)

# create variables for use later
  rdrs <- rlocs$reader
  nrdrs <- length(rdrs)
  
# create movement dataset
  birds_all <- unique(vis.sort$bird)
  yrs <- sort(unique(vis.sort$year))
  mv.colnames <- c("reader1", "reader2", "year", "count")
  mv <- matrix(nrow = 1, ncol = length(mv.colnames))
  colnames(mv) <- mv.colnames
  mv <- as.data.frame(mv)

# Fill dataframe with movements
  for(y in yrs){
    df_temp <- subset(vis.sort, year==y)
    df_temp <- df_temp[order(df_temp$bird, df_temp$day, df_temp$seconds), ]
    ds <- 0
    cnts <- matrix(data=0, nrow = nrdrs, ncol = nrdrs)
     if(nrow(df_temp) > 1){
      for(i in 2:nrow(df_temp)){
        if(df_temp$date[i] == df_temp$date[i-1] &
           (df_temp$bird[i] == df_temp$bird[i-1]) &
            (df_temp$reader[i] != df_temp$reader[i-1])){
            r1 <- which(rdrs == df_temp$reader[i-1])
            r2 <- which(rdrs == df_temp$reader[i])
            
            cnts[r1,r2] <- cnts[r1,r2] + 1
        }
      }
     }
      # combine with movement dataframe
      if(y=="2014"){
        rems <- which(rlocs$meadow_complex == "CM" | rlocs$meadow_complex == "LOM")
        cnts_y <- cnts[-rems,-rems]
        rdrs_y <- rdrs[-rems]
      } else if(y=="2015"){
        rems <- which(rlocs$meadow_complex == "CM")
        rdrs_y <- rdrs[-rems]
        cnts_y <- cnts[-rems,-rems]
      } else{
        rdrs_y <- rdrs
        cnts_y <- cnts
      }
        df_temp2 <- data.frame(reader1=rep(rdrs_y, length(rdrs_y)),
                               reader2=rep(rdrs_y, each=length(rdrs_y)),
                               year=rep(y, length(rdrs_y)^2),
                               count=as.vector(cnts_y))
        mv <- rbind(mv, df_temp2)
    
  }
  
  mv <- mv[-1,]
      
```


Remove rows for $i \to i$ movements.

```{r}

  rows_ii <- double()
  for(i in 1:nrow(mv)){
    if(mv$reader1[i] == mv$reader2[i]){
      rows_ii <- c(rows_ii,i)
    }
  }

  mv <- mv[-rows_ii, ]

```

 Now add in spatial data pertaining to each "edge": distance between readers, proportion of intervening forest, and cover types connected by the edge (i.e. meadow-meadow, meadow-mix, meadow-forest, meadow-scrub).
 
**Edge length**
```{r edge distances}
 
  # rlocs$x.std <- (rlocs$x - mean(rlocs$x))/sd(rlocs$x)
  # rlocs$y.std <- (rlocs$y - mean(rlocs$y))/sd(rlocs$y)

  coords_r <- as.matrix(rlocs[,c("x","y")])
  ones <- matrix(1, nrow = nrow(coords_r), ncol = 1)

# compute euclidean distance matrix
  D_rsq <- diag(coords_r%*%t(coords_r))%*%t(ones) + ones%*%t(diag(coords_r%*%t(coords_r))) - 2*(coords_r%*%t(coords_r))
  
  D_r <- sqrt(D_rsq)
  rownames(D_r) <- rlocs$reader
  colnames(D_r) <- rownames(D_r)
  
  dist.list <- data.frame(reader1=rep(rdrs,nrdrs),
                          reader2=rep(rdrs, each=nrdrs),
                          dist.km=as.vector(D_r)/1000)
# add distance to movement data
  mv$edgename <- paste(mv$reader1, mv$reader2, sep = "-")
  dist.list$edgename <- paste(dist.list$reader1, dist.list$reader2, sep = "-")
  mv2 <- merge(mv, dist.list[,c(3,4)])

```

$~$

**Cover types**

```{r cover types}
#habitat for reader 1
  mv2 <- merge(mv2, rlocs[,c(1,6)], by.x="reader1", by.y="reader")
  names(mv2)[which(names(mv2)=="habitat")] <- "hab1"
  
#habitat for reader 2
  mv2 <- merge(mv2, rlocs[,c(1,6)], by.x="reader2", by.y="reader")
  names(mv2)[which(names(mv2)=="habitat")] <- "hab2"
  
# connectivity reader 1
  mv2 <- merge(mv2, rlocs[,c(1,10)], by.x="reader1", by.y="reader")
  names(mv2)[which(names(mv2) == "prop_for100")] <- "p_for1"
  
# connectivity reader 2
  mv2 <- merge(mv2, rlocs[,c(1,10)], by.x="reader2", by.y="reader")
  names(mv2)[which(names(mv2) == "prop_for100")] <- "p_for2" 

```

$~$

**Proportion of forest vs. non-forest cells intersected by each edge**

```{r proportion forest}

# Create points data
 utm.prj4 <- "+proj=utm +zone=10 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
 crs <- st_crs(utm.prj4)

  readers.sp <- st_multipoint(coords_r, dim = "XY")

  reader.points <- st_cast(st_geometry(readers.sp), "POINT") 
  st_crs(reader.points) <- crs
# Build line pairs
  
  linestrings <- list()
  
  for(j in 2:nrow(readers.sp)){
    for(i in 1:(j-1)){
      pair_ij <- st_combine(c(reader.points[i], reader.points[j]))
      linestrings[[length(linestrings)+1]] <- pair_ij
    }
  }


# combine all linestrings into one object
  
  edges.sp <- st_multilinestring(do.call("rbind", linestrings))
  
  edges.aslines <- st_cast(st_geometry(edges.sp), "MULTILINESTRING")
    st_crs(edges.aslines) <- crs

  
  forest <- raster("~/Documents/Columbine/Data/GIS_Data/forest.tif")
  
#Extract proportion of edge covered by forest using the 'forest' raster
  prop.for <- lapply(X=1:length(linestrings),
                     FUN = function(x){
                       extract(forest, st_sf(st_cast(st_geometry(linestrings[[x]]), "LINESTRING")), fun=mean, na.rm=T, df=T)
                     })
  
  prop.for.df <- matrix(unlist(prop.for), ncol = 2, byrow = T)
  prop.for.mat <- matrix(data = 0, nrow = nrdrs, ncol = nrdrs)
  prop.for.mat[lower.tri(prop.for.mat)] <- prop.for.df[,2]
  mat2 <- t(prop.for.mat)
  prop.for.mat <- prop.for.mat + mat2
  diag(prop.for.mat) <- NA
  
  prop.for.list <- data.frame(reader1=rep(rdrs, nrdrs),
                              reader2=rep(rdrs, each=nrdrs),
                              prop.for=as.vector(prop.for.mat))
  prop.for.list$edgename <- paste(prop.for.list$reader1, prop.for.list$reader2, sep="-")
  
#merge two datasets
   mv3 <- merge(mv2, prop.for.list[,c(3,4)])
# days each reader was active
   # mv5 <- merge(mv5, rlocs[,c(1,9)], by.x="reader1", by.y="reader")
   # mv5 <- merge(mv5, rlocs[,c(1,9)], by.x="reader2", by.y="reader")
   
   cols.order <- c("reader1", "reader2", "year", "hab1", "hab2", 
                   "p_for1", "p_for2", "dist.km", "prop.for", "count")
   mv4 <- mv3[,cols.order]
   
  names(mv4) <- c("reader_i", "reader_j", "year", "hab_i", "hab_j",
                  "pfor_100m_i", "pfor_100m_j", "dist_ij", "pfor_ij", "count")
  
# now create a dyad identifier
  mv4$dyad <- NA
  for(i in 1:nrow(mv4)){
    dyad_i <- sort(c(mv4$reader_i[i], mv4$reader_j[i]))
    mv4$dyad[i] <- paste(dyad_i, collapse = '-')
  }
  
  mv4 <- mv4[,c(1,2,11,3:10)]

```

Include a column for the number of days each reader was active on the landscape for each year.

```{r}

  active_days <- data.frame(year=unique(mv4$year),
                            active_days = c(11,64,54,50))

  mv5 <- merge(mv4, active_days)

```


```{r final undirected data}

  mv5 <- mv5[order(mv5$year, mv5$reader_i, mv5$reader_j),]
 
  write.table(mv5, file = "~/Documents/Columbine/Data/Bird_data/total_movements_by_year.tsv", row.names = F, sep = "\t",
             quote = F)

```


Now create a "directed" dataset with layers of sparse matrices for estimating $Pr(y_{ij} = 1)$, where $y_{ij}$ indicates the presence of an edge between reader $i$ and $j$.

```{r}

# create adjacency matrix
  A <- matrix(data = 0, nrow = nrow(rlocs), ncol = nrow(rlocs))
  diag(A) <- NA

# fill in names for nodes
  rownames(A) <- as.character(rlocs$reader)
  colnames(A) <- as.character(rlocs$reader)

# one set of data summarizing by days
  d <- unique(mv[,which(names(mv) == "date")])
  
# one set of data with days*birds
  db <- unique(mv[,which(names(mv) %in% c("bird", "date"))])
  
# lists of matrices
  sparse_mats.d <- vector(mode = "list", length = length(d))
  sparse_mats.db <- vector(mode = "list", length = nrow(db))
  
# fill in data
  for(i in 1:length(d)){
    df_i <- subset(mv, date == d[i])
    sparse_mats.d[[i]] <- list(mat=A, date=d[i])
    for(k in 1:nrow(df_i)){
      # fill in adjacency matrix with presence/absence of movement
      pos_k <- c(which(rownames(A) == as.character(df_i$reader1[k])),
                 which(colnames(A) == as.character(df_i$reader2[k])))
      sparse_mats.d[[i]]$mat[pos_k[1], pos_k[2]] <- 1
    }
  }
  
  
  for(i in 1:nrow(db)){
    
    df_i <- subset(mv, bird == db[i,1] &
                       date == db[i,2])
    sparse_mats[[i]] <- list(mat=A, date=unique(df_i$date), bird=unique(df_i$bird))
    for(k in 1:nrow(df_i)){
      # fill in adjacency matrix with ones
      pos_k <- c(which(rownames(A) == as.character(df_i$reader1[k])),
                 which(colnames(A) == as.character(df_i$reader2[k])))
      sparse_mats[[i]]$mat[pos_k[1], pos_k[2]] <- 1
    }
    
  }
  
# edge data as matrices
  # upper triangle of matrix is stored above as prop.for.df
  prop.for.mat <- A
    prop.for.mat[upper.tri(prop.for.mat, diag = F)] <- prop.for.df[,2]
    prop.for.mat[lower.tri(prop.for.mat, diag = F)] <- t(prop.for.mat)[lower.tri(prop.for.mat)]
  
  save(mv, prop.for.mat, D_r, rlocs, sparse_mats.d, sparse_mats.db, 
       file = "~/Documents/Columbine/Data/Bird_data/network_model.RData")
  
```


**References**


















