---
title: "Population Structure Analysis"
author: "Dusty Gannon"
date: "2/4/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Packages

  require(ggplot2)
  require(vcfR)
  require(hierfstat)
  require(stringr)
  require(reshape2)
  require(purrr)
  require(sf)
  require(raster)
  require(popgraph)
  require(igraph)

```

\subsection{General Population Structure}

Load vcf file and convert genotype matrix into allelic load, where $X_{il}\in \{0,1,2\}$ for individual $i$ and locus $l$: 0 = for homozygous for the alternative allele; 1 = heterozygous; 2 = homozygous for the reference allele, respectively.

```{r}
  col.vcf <- read.vcfR("~/Documents/Columbine/Data/GBS_Data/AQFO_snps_postfilt_impute.vcf")


  col.gt <- extract.gt(col.vcf, element = "GT", as.numeric = F)
  
# Function to convert to allelic load
  
  allele.load <-  function(x, sep="\\|"){
    spl <- str_split(x, pattern = sep, n=2, simplify = T)
    as.numeric(spl[,1])+as.numeric(spl[,2])
  }
  
  
  col.ald <- apply(col.gt, 2, allele.load)
  
  rownames(col.ald) <- rownames(col.gt)
  colnames(col.ald) <- colnames(col.gt)
  
  col.ald <- t(col.ald)
  
```


**Create a mean-centered allelic loading matrix**

```{r}

  col.aldc <- apply(col.ald, 2, function(x){x-mean(x)})

```


$~$

  Merge population data with the allelic load matrix to make sure rows are ordered correctly:
  
  
```{r}
 
  col.ald.df <- as.data.frame(col.aldc) # make into df for merge
    col.ald.df <- cbind(rownames(col.ald.df), col.ald.df)
    names(col.ald.df)[1] <- "Sample"

  samp.dat <- read.table("~/Documents/Columbine/Data/sequenced_samples.txt", header = T, as.is = T, sep = "\t")

  samp.dat.sub <- samp.dat[, c("Sample", "COMPLEX", "MEADOW_ID")]
  
  col.dat <- merge(samp.dat.sub, col.ald.df)
  
  col.dat <- col.dat[order(col.dat$COMPLEX, col.dat$MEADOW_ID), ]
  
```

  With this dataset, look into population structure:
  
\subsection{DC-PCA}

  Following the recommendations of [@gauch2019], we double-center the snp-loading matrix after re-coding to be sure that the rare allele is coded as 1 and the common allele as 0. The double-centered matrix can be expressed as
  
$$
{\bf M}_{\text{DC}} = {\bf X} - \bar {\bf X}_j - \bar {\bf X}_i + \bar {\bf X},
$$
where ${\bf X}_{(n\times m)}$ is the data matrix, $\bar {\bf X}_j$ is a matrix with the column means of $\bf X$ repeated across rows of the respective columns, $\bar {\bf X}_i$ is a matrix with the row means of ${\bf X}$ repeated across columns of respective rows, and $\bar {\bf X}$ is the mean of all elements in the matrix.

```{r}

  recode <- function(X, ploidy=2){
    n <- nrow(X)
    good <- apply(X, 2, function(x){sum(x==2)*2 + sum(x==1)})/(n*ploidy)
    indices <- which(good > 0.5)
    for(i in indices){
      X[,i] <- (-1*X[,i]) + 2
    }
    return(X)
  }

  col.ald.rc <- recode(col.ald)
  r <- nrow(col.ald.rc)
  c <- ncol(col.ald.rc)
 
#column centered
  
  X_c <- apply(col.ald.rc, 2, function(x){x-mean(x)})
  X_cr <- apply(X_c, 1, function(x){x-mean(x)})
  
  col.dc <- X_cr + mean(X_cr)
  
  
#PCA with dc matrix
  
  col.pca <- prcomp(t(col.dc))
  
# compile data for plotting
  
  pca.df <- data.frame(Sample=rownames(col.pca$x), PC1=col.pca$x[,1], PC2=col.pca$x[,2])
  
  pca.df$Sample <- as.character(pca.df$Sample)
  
  pca.df <- merge(pca.df, samp.dat.sub)
  
  ggplot(data = pca.df, aes(x=PC1, y=PC2, group=COMPLEX))+
    geom_point(aes(color=MEADOW_ID, shape=COMPLEX))

```


\section{Population graphs}

```{r}

  col.aldc.ord <- as.matrix(col.dat[,-c(1:3)])

  col.pg <- popgraph(col.aldc.ord, factor(col.dat$MEADOW_ID))
  
## Add attributes to nodes
  
  x <- (samp.dat[,c("MEADOW_ID", "X_COORD")] %>% group_by(MEADOW_ID) %>% summarise(x_cent = mean(X_COORD)))$x_cent
  y <-  (samp.dat[,c("MEADOW_ID", "Y_COORD")] %>% group_by(MEADOW_ID) %>% summarise(y_cent = mean(Y_COORD)))$y_cent
  
  meadow_layout <- matrix(c(x,y), ncol=2)
  
  ggplot() + geom_edgeset(aes(x,y),col.pg, color="grey", size=(E(col.pg)$weight)^2) +
    geom_nodeset(aes(x,y), col.pg, size=(V(col.pg)$size)/5)+
    theme_classic()


```





```{r}

  col.ald.df <- as.data.frame(col.ald) # make into df for merge
    col.ald.df <- cbind(rownames(col.ald.df), col.ald.df)
    names(col.ald.df)[1] <- "Sample"

  samp.dat.sub <- samp.dat[, c("Sample", "COMPLEX", "MEADOW_ID")]
  
  col.dat <- merge(samp.dat.sub, col.ald.df)
  
  col.dat <- col.dat[order(col.dat$COMPLEX, col.dat$MEADOW_ID), ]
# General stuff
  # Allelic richness
   popstats <- basic.stats(col.dat[,-c(1,3)])

# compute beta statistics using meadow as the population identifier
  beta.pop <- betas(col.dat[,-c(1,2)], nboot = 100, lim = c(0.025, 0.975))
  
  pop.dat <- unique(samp.dat[, -c(1:4, 12:19)])
  
  kinpop.dat <- data.frame(unique(col.dat$MEADOW_ID))
    names(kinpop.dat) <- "MEADOW_ID"
    
  kinpop.dat$beta <- beta.pop[[1]]
  kinpop.dat$beta.low <- beta.pop[[2]][1,]
  kinpop.dat$beta.high <- beta.pop[[2]][2,]
    
  kinpop.dat <- merge(kinpop.dat, pop.dat)

```


```{r}
#Funtion from Goudet et al. (2019)
  beta.coan.SNPs<-function(dat){
  #dat is a data frame with individuals in rows and allelic dosage for each locus in colums  
  #uses matching proba -same equation as for population i.e. Mij=[xiXj+(2-xi)(2-xj)]/4
  dat<-as.matrix(dat)
  nl<-dim(dat)[2]
  Mij<-(tcrossprod(dat)+tcrossprod(2-dat))/4
  diag(Mij)<-NA
  Mb<-mean(Mij,na.rm=T)
  (Mij-Mb)/(nl-Mb)
}

  
  coan.mat <- beta.coan.SNPs(col.ald)

  coan.mat[upper.tri(coan.mat)] <- NA
  
  coan.pwdf <- subset(melt(coan.mat), value!="NA")
  
```

 Plotting ancestry coefficients against pairwise distance

```{r}

  geodist.mat <- matrix(NA, nrow = dim(samp.dat)[1], ncol = dim(samp.dat)[1])
    coords <- as.matrix(samp.dat[,c("X_COORD", "Y_COORD")])

for(i in 1:nrow(samp.dat)){
  xs <- (coords[,1] - coords[i,1])^2
  ys <- (coords[,2] - coords[i,2])^2
  
  geodist.mat[,i] <- sqrt(xs+ys)
}
    
  colnames(geodist.mat) <- samp.dat$Sample
  rownames(geodist.mat) <- samp.dat$Sample
    
  geodist.mat[upper.tri(geodist.mat, diag = T)] <- NA
  
  geo.pwdf <- subset(melt(geodist.mat), value!="NA")
  
# check that just binding the columns is okay
  
  for(j in 1:2){
    geo.pwdf[,j] <- as.character(geo.pwdf[,j])
    coan.pwdf[,j] <- as.character(coan.pwdf[,j])
  }
  
  all.equal(geo.pwdf[,1:2], coan.pwdf[,1:2])
  
# Now combine the two datasets
  
  ibd.pwdf <- as.data.frame(cbind(coan.pwdf, geo.pwdf[,3]))
    names(ibd.pwdf) <- c("s1", "s2", "beta", "geodist_m")
    
  m1 <- lmer(beta~log(geodist_m) + (1|s1), data = ibd.pwdf)
    
ggplot(data=ibd.pwdf, aes(x=log(geodist_m), y=beta))+
    geom_point(alpha=0.5)+
    geom_abline(slope = m1@beta[2], intercept = m1@beta[1])+
    ylim(c(-1, 1))

```
  



 Given each individual plant's location, we want to calculate the proportion of surrounding forest in 50, 100, and 500m.
 
```{r}

  forest <- raster("~/Documents/Columbine/Data/GIS_Data/forest.tif")

  samp.dat$S_PROPF_50 <- extract(forest, as.matrix(samp.dat[,c("X_COORD", "Y_COORD")]), buffer = 50, fun=mean, na.rm=T)
  samp.dat$S_PROPF_100 <- extract(forest, as.matrix(samp.dat[,c("X_COORD", "Y_COORD")]), buffer = 100, fun=mean, na.rm=T)
  samp.dat$S_PROPF_500 <- extract(forest, as.matrix(samp.dat[,c("X_COORD", "Y_COORD")]), buffer = 500, fun=mean, na.rm=T)
```








